// Code generated by math.goal. DO NOT EDIT.

package goal

import "math"

func VSin(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fSin(args[0])
	default:
		return panicRank("sin")
	}
}

func fSin(x V) V {
	if x.IsI() {
		return NewF(math.Sin(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Sin(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fSin(fromABtoAF(xv))
	case *AI:
		return fSin(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Sin(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fSin(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("sin x", "x", x)
	}
}

func VCos(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fCos(args[0])
	default:
		return panicRank("cos")
	}
}

func fCos(x V) V {
	if x.IsI() {
		return NewF(math.Cos(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Cos(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fCos(fromABtoAF(xv))
	case *AI:
		return fCos(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Cos(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fCos(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("cos x", "x", x)
	}
}

func VTan(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fTan(args[0])
	default:
		return panicRank("tan")
	}
}

func fTan(x V) V {
	if x.IsI() {
		return NewF(math.Tan(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Tan(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fTan(fromABtoAF(xv))
	case *AI:
		return fTan(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Tan(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fTan(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("tan x", "x", x)
	}
}

func VAsin(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fAsin(args[0])
	default:
		return panicRank("asin")
	}
}

func fAsin(x V) V {
	if x.IsI() {
		return NewF(math.Asin(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Asin(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fAsin(fromABtoAF(xv))
	case *AI:
		return fAsin(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Asin(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fAsin(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("asin x", "x", x)
	}
}

func VAcos(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fAcos(args[0])
	default:
		return panicRank("acos")
	}
}

func fAcos(x V) V {
	if x.IsI() {
		return NewF(math.Acos(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Acos(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fAcos(fromABtoAF(xv))
	case *AI:
		return fAcos(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Acos(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fAcos(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("acos x", "x", x)
	}
}

func VAtan(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fAtan(args[0])
	default:
		return panicRank("atan")
	}
}

func fAtan(x V) V {
	if x.IsI() {
		return NewF(math.Atan(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Atan(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fAtan(fromABtoAF(xv))
	case *AI:
		return fAtan(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Atan(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fAtan(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("atan x", "x", x)
	}
}

func VExp(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fExp(args[0])
	default:
		return panicRank("exp")
	}
}

func fExp(x V) V {
	if x.IsI() {
		return NewF(math.Exp(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Exp(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fExp(fromABtoAF(xv))
	case *AI:
		return fExp(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Exp(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fExp(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("exp x", "x", x)
	}
}

func VLog(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		return fLog(args[0])
	default:
		return panicRank("log")
	}
}

func fLog(x V) V {
	if x.IsI() {
		return NewF(math.Log(float64(x.I())))
	}
	if x.IsF() {
		return NewF(math.Log(x.F()))
	}
	switch xv := x.value.(type) {
	case *AB:
		return fLog(fromABtoAF(xv))
	case *AI:
		return fLog(toAF(xv))
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = math.Log(xi)
		}
		return NewV(r)
	case *AV:
		r := xv.reuse()
		for i, xi := range xv.Slice {
			r.Slice[i] = fLog(xi)
			if r.Slice[i].IsPanic() {
				return r.Slice[i]
			}
		}
		return NewV(r)
	default:
		return panicType("log x", "x", x)
	}
}
