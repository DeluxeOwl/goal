// Code generated by genop.pl. DO NOT EDIT.

package main

import (
	"math"
	"strings"
)

// Equal returns w=x.
func Equal(w, x V) V {
	switch w := w.(type) {
	case B:
		return EqualBV(w, x)
	case F:
		return EqualFV(w, x)
	case I:
		return EqualIV(w, x)
	case S:
		return EqualSV(w, x)
	case AB:
		return EqualABV(w, x)
	case AF:
		return EqualAFV(w, x)
	case AI:
		return EqualAIV(w, x)
	case AS:
		return EqualASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("=")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Equal(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Equal(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w == x
	case F:
		return B2F(w) == x
	case I:
		return B2I(w) == x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) == B(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) == I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := EqualBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w == B2F(x)
	case F:
		return w == x
	case I:
		return w == F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := EqualFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w == B2I(x)
	case F:
		return F(w) == x
	case I:
		return w == x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := EqualIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w == x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) == S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := EqualSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) == B(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) == B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) == I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

// NotEqual returns w≠x.
func NotEqual(w, x V) V {
	switch w := w.(type) {
	case B:
		return NotEqualBV(w, x)
	case F:
		return NotEqualFV(w, x)
	case I:
		return NotEqualIV(w, x)
	case S:
		return NotEqualSV(w, x)
	case AB:
		return NotEqualABV(w, x)
	case AF:
		return NotEqualAFV(w, x)
	case AI:
		return NotEqualAIV(w, x)
	case AS:
		return NotEqualASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("≠")
			}
			r := make(AV, len(w))
			for i := range r {
				v := NotEqual(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := NotEqual(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w != x
	case F:
		return B2F(w) != x
	case I:
		return B2I(w) != x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) != B(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) != F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) != I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := NotEqualBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w != B2F(x)
	case F:
		return w != x
	case I:
		return w != F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) != B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) != F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) != F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := NotEqualFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w != B2I(x)
	case F:
		return F(w) != x
	case I:
		return w != x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) != B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) != F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) != I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := NotEqualIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w != x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) != S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := NotEqualSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) != B(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) != F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) != I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) != B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) != F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) != I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AV, len(x))
		for i := range r {
			v := NotEqualBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) != B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) != F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) != F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) != B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) != F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) != F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AV, len(x))
		for i := range r {
			v := NotEqualFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) != B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) != F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) != I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) != B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) != F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) != I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AV, len(x))
		for i := range r {
			v := NotEqualIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) != S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) != S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AV, len(x))
		for i := range r {
			v := NotEqualSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

// Lesser returns w<x.
func Lesser(w, x V) V {
	switch w := w.(type) {
	case B:
		return LesserBV(w, x)
	case F:
		return LesserFV(w, x)
	case I:
		return LesserIV(w, x)
	case S:
		return LesserSV(w, x)
	case AB:
		return LesserABV(w, x)
	case AF:
		return LesserAFV(w, x)
	case AI:
		return LesserAIV(w, x)
	case AS:
		return LesserASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("<")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Lesser(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Lesser(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return !w && x
	case F:
		return B2F(w) < x
	case I:
		return B2I(w) < x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(!w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) < I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w < B2F(x)
	case F:
		return w < x
	case I:
		return w < F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w < B2I(x)
	case F:
		return F(w) < x
	case I:
		return w < x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w < x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) < S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(!w[i]) && B(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(!w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) < I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

// LesserEq returns w≤x.
func LesserEq(w, x V) V {
	switch w := w.(type) {
	case B:
		return LesserEqBV(w, x)
	case F:
		return LesserEqFV(w, x)
	case I:
		return LesserEqIV(w, x)
	case S:
		return LesserEqSV(w, x)
	case AB:
		return LesserEqABV(w, x)
	case AF:
		return LesserEqAFV(w, x)
	case AI:
		return LesserEqAIV(w, x)
	case AS:
		return LesserEqASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("≤")
			}
			r := make(AV, len(w))
			for i := range r {
				v := LesserEq(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := LesserEq(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return x || !w
	case F:
		return B2F(w) <= x
	case I:
		return B2I(w) <= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(x[i]) || B(!w))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) <= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) <= I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserEqBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w <= B2F(x)
	case F:
		return w <= x
	case I:
		return w <= F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) <= B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) <= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) <= F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserEqFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w <= B2I(x)
	case F:
		return F(w) <= x
	case I:
		return w <= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) <= B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) <= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) <= I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserEqIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w <= x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) <= S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := LesserEqSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(x) || B(!w[i]))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) <= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) <= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(x[i]) || B(!w[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) <= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) <= I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserEqBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) <= B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) <= B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserEqFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) <= B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) <= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) <= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) <= B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) <= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) <= I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserEqIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) <= S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) <= S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserEqSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

// Greater returns w>x.
func Greater(w, x V) V {
	switch w := w.(type) {
	case B:
		return GreaterBV(w, x)
	case F:
		return GreaterFV(w, x)
	case I:
		return GreaterIV(w, x)
	case S:
		return GreaterSV(w, x)
	case AB:
		return GreaterABV(w, x)
	case AF:
		return GreaterAFV(w, x)
	case AI:
		return GreaterAIV(w, x)
	case AS:
		return GreaterASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen(">")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Greater(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Greater(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w && !x
	case F:
		return B2F(w) > x
	case I:
		return B2I(w) > x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(!x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) > I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w > B2F(x)
	case F:
		return w > x
	case I:
		return w > F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w > B2I(x)
	case F:
		return F(w) > x
	case I:
		return w > x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w > x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) > S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(!x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(!x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) > I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

// GreaterEq returns w≥x.
func GreaterEq(w, x V) V {
	switch w := w.(type) {
	case B:
		return GreaterEqBV(w, x)
	case F:
		return GreaterEqFV(w, x)
	case I:
		return GreaterEqIV(w, x)
	case S:
		return GreaterEqSV(w, x)
	case AB:
		return GreaterEqABV(w, x)
	case AF:
		return GreaterEqAFV(w, x)
	case AI:
		return GreaterEqAIV(w, x)
	case AS:
		return GreaterEqASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("≥")
			}
			r := make(AV, len(w))
			for i := range r {
				v := GreaterEq(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := GreaterEq(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w || !x
	case F:
		return B2F(w) >= x
	case I:
		return B2I(w) >= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) || B(!x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) >= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) >= I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterEqBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w >= B2F(x)
	case F:
		return w >= x
	case I:
		return w >= F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) >= B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) >= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) >= F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterEqFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w >= B2I(x)
	case F:
		return F(w) >= x
	case I:
		return w >= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) >= B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) >= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) >= I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterEqIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w >= x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) >= S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := GreaterEqSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) || B(!x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) >= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) >= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) || B(!x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) >= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) >= I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterEqBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) >= B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) >= B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterEqFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) >= B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) >= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) >= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) >= B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) >= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) >= I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterEqIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) >= S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) >= S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterEqSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

// Add returns w+x.
func Add(w, x V) V {
	switch w := w.(type) {
	case B:
		return AddBV(w, x)
	case F:
		return AddFV(w, x)
	case I:
		return AddIV(w, x)
	case S:
		return AddSV(w, x)
	case AB:
		return AddABV(w, x)
	case AF:
		return AddAFV(w, x)
	case AI:
		return AddAIV(w, x)
	case AS:
		return AddASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("+")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Add(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Add(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return B2I(w) + B2I(x)
	case F:
		return B2F(w) + x
	case I:
		return B2I(w) + x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) + B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) + F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) + I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AddBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w + B2F(x)
	case F:
		return w + x
	case I:
		return w + F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AddFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w + B2I(x)
	case F:
		return F(w) + x
	case I:
		return w + x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) + F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AddIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return w + x
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w) + S(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AddSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(S(w[i]) + S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w[i]) + S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

// Subtract returns w-x.
func Subtract(w, x V) V {
	switch w := w.(type) {
	case B:
		return SubtractBV(w, x)
	case F:
		return SubtractFV(w, x)
	case I:
		return SubtractIV(w, x)
	case S:
		return SubtractSV(w, x)
	case AB:
		return SubtractABV(w, x)
	case AF:
		return SubtractAFV(w, x)
	case AI:
		return SubtractAIV(w, x)
	case AS:
		return SubtractASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("-")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Subtract(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Subtract(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return B2I(w) - B2I(x)
	case F:
		return B2F(w) - x
	case I:
		return B2I(w) - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) - I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SubtractBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w - B2F(x)
	case F:
		return w - x
	case I:
		return w - F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SubtractFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w - B2I(x)
	case F:
		return F(w) - x
	case I:
		return w - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SubtractIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return strings.TrimSuffix(w, x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SubtractSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.TrimSuffix(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

// Span returns w¬x.
func Span(w, x V) V {
	switch w := w.(type) {
	case B:
		return SpanBV(w, x)
	case F:
		return SpanFV(w, x)
	case I:
		return SpanIV(w, x)
	case AB:
		return SpanABV(w, x)
	case AF:
		return SpanAFV(w, x)
	case AI:
		return SpanAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("¬")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Span(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Span(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return 1 + B2I(w) - B2I(x)
	case F:
		return 1 + B2F(w) - x
	case I:
		return 1 + B2I(w) - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w)) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + B2F(B(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w)) - I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SpanBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return 1 + w - B2F(x)
	case F:
		return 1 + w - x
	case I:
		return 1 + w - F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w) - B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w) - F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w) - F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SpanFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return 1 + w - B2I(x)
	case F:
		return 1 + F(w) - x
	case I:
		return 1 + w - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(I(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w) - I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := SpanIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + B2F(B(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + B2F(B(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SpanBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SpanFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + I(w[i]) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(I(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w[i]) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(I(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w[i]) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AV, len(x))
		for i := range r {
			v := SpanIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

// Multiply returns w×x.
func Multiply(w, x V) V {
	switch w := w.(type) {
	case B:
		return MultiplyBV(w, x)
	case F:
		return MultiplyFV(w, x)
	case I:
		return MultiplyIV(w, x)
	case S:
		return MultiplySV(w, x)
	case AB:
		return MultiplyABV(w, x)
	case AF:
		return MultiplyAFV(w, x)
	case AI:
		return MultiplyAIV(w, x)
	case AS:
		return MultiplyASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("×")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Multiply(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Multiply(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w && x
	case F:
		return B2F(w) * x
	case I:
		return B2I(w) * x
	case S:
		return strings.Repeat(x, B2I(w))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) * I(x[i]))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), B2I(B(w))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MultiplyBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w * B2F(x)
	case F:
		return w * x
	case I:
		return w * F(x)
	case S:
		return strings.Repeat(x, I(math.Round(float64(w))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(I(x[i])))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(math.Round(float64(F(w))))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MultiplyFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w * B2I(x)
	case F:
		return F(w) * x
	case I:
		return w * x
	case S:
		return strings.Repeat(x, w)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * I(x[i]))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(w)))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MultiplyIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplySV(w S, x V) V {
	switch x := x.(type) {
	case B:
		return strings.Repeat(w, B2I(x))
	case F:
		return strings.Repeat(w, I(math.Round(float64(x))))
	case I:
		return strings.Repeat(w, x)
	case AB:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w), I(math.Round(float64(F(x[i]))))))
		}
		return r
	case AI:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MultiplySV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(x), B2I(B(w[i]))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), B2I(B(w[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x)))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(x), I(math.Round(float64(F(w[i]))))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x[i])))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(math.Round(float64(F(w[i]))))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(x), I(w[i])))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(w[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyASV(w AS, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(math.Round(float64(F(x))))))
		}
		return r
	case I:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(math.Round(float64(F(x[i]))))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplySV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

// Divide returns w÷x.
func Divide(w, x V) V {
	switch w := w.(type) {
	case B:
		return DivideBV(w, x)
	case F:
		return DivideFV(w, x)
	case I:
		return DivideIV(w, x)
	case AB:
		return DivideABV(w, x)
	case AF:
		return DivideAFV(w, x)
	case AI:
		return DivideAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("÷")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Divide(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Divide(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return divide(B2F(w), B2F(x))
	case F:
		return divide(B2F(w), x)
	case I:
		return divide(B2F(w), F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w)), B2F(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w)), F(I(x[i]))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := DivideBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return divide(w, B2F(x))
	case F:
		return divide(w, x)
	case I:
		return divide(w, F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), B2F(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), F(I(x[i]))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := DivideFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return divide(F(w), B2F(x))
	case F:
		return divide(F(w), x)
	case I:
		return divide(F(w), F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), B2F(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), F(I(x[i]))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := DivideIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), B2F(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), B2F(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AV, len(x))
		for i := range r {
			v := DivideBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), B2F(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), B2F(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AV, len(x))
		for i := range r {
			v := DivideFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), B2F(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), B2F(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AV, len(x))
		for i := range r {
			v := DivideIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

// Minimum returns w⌊x.
func Minimum(w, x V) V {
	switch w := w.(type) {
	case B:
		return MinimumBV(w, x)
	case F:
		return MinimumFV(w, x)
	case I:
		return MinimumIV(w, x)
	case S:
		return MinimumSV(w, x)
	case AB:
		return MinimumABV(w, x)
	case AF:
		return MinimumAFV(w, x)
	case AI:
		return MinimumAIV(w, x)
	case AS:
		return MinimumASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("⌊")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Minimum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Minimum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w && x
	case F:
		return F(math.Min(float64(B2F(w)), float64(x)))
	case I:
		return minI(B2I(w), x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(B(w))), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(B2I(B(w)), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MinimumBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return F(math.Min(float64(w), float64(B2F(x))))
	case F:
		return F(math.Min(float64(w), float64(x)))
	case I:
		return F(math.Min(float64(w), float64(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MinimumFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return minI(w, B2I(x))
	case F:
		return F(math.Min(float64(w), float64(x)))
	case I:
		return minI(w, x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MinimumIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return minS(w, x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MinimumSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(B(w[i]))), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(B2I(B(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(B(w[i]))), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(B2I(B(w[i])), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(B(x))))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

// Maximum returns w⌈x.
func Maximum(w, x V) V {
	switch w := w.(type) {
	case B:
		return MaximumBV(w, x)
	case F:
		return MaximumFV(w, x)
	case I:
		return MaximumIV(w, x)
	case S:
		return MaximumSV(w, x)
	case AB:
		return MaximumABV(w, x)
	case AF:
		return MaximumAFV(w, x)
	case AI:
		return MaximumAIV(w, x)
	case AS:
		return MaximumASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("⌈")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Maximum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Maximum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w || x
	case F:
		return F(math.Max(float64(B2F(w)), float64(x)))
	case I:
		return maxI(B2I(w), x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) || B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(B(w))), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(B2I(B(w)), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MaximumBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return F(math.Max(float64(w), float64(B2F(x))))
	case F:
		return F(math.Max(float64(w), float64(x)))
	case I:
		return F(math.Max(float64(w), float64(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MaximumFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return maxI(w, B2I(x))
	case F:
		return F(math.Max(float64(w), float64(x)))
	case I:
		return maxI(w, x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MaximumIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return maxS(w, x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := MaximumSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(B(w[i]))), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(B2I(B(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(B(w[i]))), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(B2I(B(w[i])), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(B(x))))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

// And returns w∧x.
func And(w, x V) V {
	switch w := w.(type) {
	case B:
		return AndBV(w, x)
	case F:
		return AndFV(w, x)
	case I:
		return AndIV(w, x)
	case AB:
		return AndABV(w, x)
	case AF:
		return AndAFV(w, x)
	case AI:
		return AndAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("∧")
			}
			r := make(AV, len(w))
			for i := range r {
				v := And(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := And(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w && x
	case F:
		return B2F(w) * x
	case I:
		return B2I(w) * x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) * I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AndBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return w * B2F(x)
	case F:
		return w * x
	case I:
		return w * F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AndFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return w * B2I(x)
	case F:
		return F(w) * x
	case I:
		return w * x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * I(x[i]))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := AndIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AndBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AndFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AV, len(x))
		for i := range r {
			v := AndIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

// Or returns w∨x.
func Or(w, x V) V {
	switch w := w.(type) {
	case B:
		return OrBV(w, x)
	case F:
		return OrFV(w, x)
	case I:
		return OrIV(w, x)
	case AB:
		return OrABV(w, x)
	case AF:
		return OrAFV(w, x)
	case AI:
		return OrAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("∨")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Or(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Or(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return w || x
	case F:
		return 1 - ((1 - B2F(w)) * (1 - x))
	case I:
		return 1 - ((1 - B2I(w)) * (1 - x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) || B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - B2F(B(w))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - B2I(B(w))) * (1 - I(x[i]))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := OrBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return 1 - ((1 - w) * (1 - B2F(x)))
	case F:
		return 1 - ((1 - w) * (1 - x))
	case I:
		return 1 - ((1 - w) * F(1-x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w)) * (1 - B2F(B(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w)) * (1 - F(x[i]))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w)) * F(1-I(x[i]))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := OrFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return 1 - ((1 - w) * (1 - B2I(x)))
	case F:
		return 1 - ((1 - F(w)) * (1 - x))
	case I:
		return 1 - ((1 - w) * (1 - x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w)) * (1 - B2I(B(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(I(w))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w)) * (1 - I(x[i]))))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := OrIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - B2F(B(w[i]))) * (1 - F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 - ((1 - B2I(B(w[i]))) * (1 - I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - B2F(B(w[i]))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - B2I(B(w[i]))) * (1 - I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AV, len(x))
		for i := range r {
			v := OrBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - B2F(B(x)))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - F(x))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * F(1-I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - B2F(B(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * F(1-I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AV, len(x))
		for i := range r {
			v := OrFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - B2I(B(x)))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(I(w[i]))) * (1 - F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - B2I(B(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(I(w[i]))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AV, len(x))
		for i := range r {
			v := OrIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

// Modulus returns w|x.
func Modulus(w, x V) V {
	switch w := w.(type) {
	case B:
		return ModulusBV(w, x)
	case F:
		return ModulusFV(w, x)
	case I:
		return ModulusIV(w, x)
	case AB:
		return ModulusABV(w, x)
	case AF:
		return ModulusAFV(w, x)
	case AI:
		return ModulusAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("|")
			}
			r := make(AV, len(w))
			for i := range r {
				v := Modulus(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Modulus(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusBV(w B, x V) V {
	switch x := x.(type) {
	case B:
		return modulus(B2I(w), B2I(x))
	case F:
		return modulus(B2I(w), I(x))
	case I:
		return modulus(B2I(w), x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w)), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w)), I(F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w)), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := ModulusBV(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusFV(w F, x V) V {
	switch x := x.(type) {
	case B:
		return modulus(I(w), B2I(x))
	case F:
		return modulus(I(w), I(x))
	case I:
		return modulus(I(w), x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w)), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w)), I(F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w)), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := ModulusFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusIV(w I, x V) V {
	switch x := x.(type) {
	case B:
		return modulus(w, B2I(x))
	case F:
		return modulus(w, I(x))
	case I:
		return modulus(w, x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w), I(F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make([]V, len(x))
		for i := range r {
			v := ModulusIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), B2I(B(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AV, len(x))
		for i := range r {
			v := ModulusBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), B2I(B(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AV, len(x))
		for i := range r {
			v := ModulusFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AV, len(x))
		for i := range r {
			v := ModulusIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}
