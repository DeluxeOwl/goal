// Code generated by genop.pl. DO NOT EDIT.

package main

import (
	"math"
	"strings"
)

// Equal returns w=x.
func Equal(w, x V) V {
	switch w := w.(type) {
	case F:
		return EqualFV(w, x)
	case I:
		return EqualIV(w, x)
	case S:
		return EqualSV(w, x)
	case AB:
		return EqualABV(w, x)
	case AF:
		return EqualAFV(w, x)
	case AI:
		return EqualAIV(w, x)
	case AS:
		return EqualASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Equal(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Equal(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func EqualFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(w == x)
	case I:
		return B2I(w == F(x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == B2F(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := EqualFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func EqualIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(F(w) == x)
	case I:
		return B2I(w == x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == B2I(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := EqualIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func EqualSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return B2I(w == x)
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) == S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := EqualSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func EqualABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(w[i] == x)
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(w[i]) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(w[i]) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] == x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(w[i]) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(w[i]) == I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func EqualAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func EqualAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func EqualASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := EqualSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Lesser returns w<x.
func Lesser(w, x V) V {
	switch w := w.(type) {
	case F:
		return LesserFV(w, x)
	case I:
		return LesserIV(w, x)
	case S:
		return LesserSV(w, x)
	case AB:
		return LesserABV(w, x)
	case AF:
		return LesserAFV(w, x)
	case AI:
		return LesserAIV(w, x)
	case AS:
		return LesserASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Lesser(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Lesser(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func LesserFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(w < x)
	case I:
		return B2I(w < F(x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < B2F(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := LesserFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func LesserIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(F(w) < x)
	case I:
		return B2I(w < x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < B2I(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := LesserIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func LesserSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return B2I(w < x)
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) < S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := LesserSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func LesserABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(!w[i] && x)
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(w[i]) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(w[i]) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(!w[i] && x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(w[i]) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(w[i]) < I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func LesserAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func LesserAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func LesserASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := LesserSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Greater returns w>x.
func Greater(w, x V) V {
	switch w := w.(type) {
	case F:
		return GreaterFV(w, x)
	case I:
		return GreaterIV(w, x)
	case S:
		return GreaterSV(w, x)
	case AB:
		return GreaterABV(w, x)
	case AF:
		return GreaterAFV(w, x)
	case AI:
		return GreaterAIV(w, x)
	case AS:
		return GreaterASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Greater(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Greater(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func GreaterFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(w > x)
	case I:
		return B2I(w > F(x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > B2F(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := GreaterFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func GreaterIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(F(w) > x)
	case I:
		return B2I(w > x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > B2I(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := GreaterIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func GreaterSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return B2I(w > x)
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) > S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := GreaterSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func GreaterABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(w[i] && !x)
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(w[i]) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(w[i]) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] && !x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(w[i]) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(w[i]) > I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func GreaterAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func GreaterAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func GreaterASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := GreaterSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Add returns w+x.
func Add(w, x V) V {
	switch w := w.(type) {
	case F:
		return AddFV(w, x)
	case I:
		return AddIV(w, x)
	case S:
		return AddSV(w, x)
	case AB:
		return AddABV(w, x)
	case AF:
		return AddAFV(w, x)
	case AI:
		return AddAIV(w, x)
	case AS:
		return AddASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Add(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Add(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func AddFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(w + x)
	case I:
		return F(w + F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + B2F(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := AddFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func AddIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(w) + x)
	case I:
		return I(w + x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + B2I(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) + F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := AddIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func AddSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(w + x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w) + S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := AddSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func AddABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) + B2I(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(w[i]) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) + B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(w[i]) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) + I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func AddAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func AddAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func AddASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(S(w[i]) + S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w[i]) + S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := AddSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Subtract returns w-x.
func Subtract(w, x V) V {
	switch w := w.(type) {
	case F:
		return SubtractFV(w, x)
	case I:
		return SubtractIV(w, x)
	case S:
		return SubtractSV(w, x)
	case AB:
		return SubtractABV(w, x)
	case AF:
		return SubtractAFV(w, x)
	case AI:
		return SubtractAIV(w, x)
	case AS:
		return SubtractASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Subtract(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Subtract(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func SubtractFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(w - x)
	case I:
		return F(w - F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - B2F(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := SubtractFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func SubtractIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(w) - x)
	case I:
		return I(w - x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - B2I(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := SubtractIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func SubtractSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(strings.TrimSuffix(string(w), string(x)))
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(w)), string(S(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := SubtractSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func SubtractABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) - B2I(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) - B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func SubtractAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func SubtractAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func SubtractASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(w[i])), string(S(x))))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(w[i])), string(S(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := SubtractSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Multiply returns w*x.
func Multiply(w, x V) V {
	switch w := w.(type) {
	case F:
		return MultiplyFV(w, x)
	case I:
		return MultiplyIV(w, x)
	case S:
		return MultiplySV(w, x)
	case AB:
		return MultiplyABV(w, x)
	case AF:
		return MultiplyAFV(w, x)
	case AI:
		return MultiplyAIV(w, x)
	case AS:
		return MultiplyASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Multiply(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Multiply(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func MultiplyFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(w * x)
	case I:
		return F(w * F(x))
	case S:
		return S(strings.Repeat(string(x), int(float64(w))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * B2F(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(I(x[i])))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(float64(F(w)))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MultiplyIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(w) * x)
	case I:
		return I(w * x)
	case S:
		return S(strings.Repeat(string(x), int(w)))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * B2I(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * I(x[i]))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(I(w))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MultiplySV(w S, x V) V {
	switch x := x.(type) {
	case F:
		return S(strings.Repeat(string(w), int(float64(x))))
	case I:
		return S(strings.Repeat(string(w), int(x)))
	case AB:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w)), int(B2I(x[i]))))
		}
		return r
	case AF:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w)), int(float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w)), int(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MultiplySV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MultiplyABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(w[i] && x)
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(B2I(w[i]))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] && x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(B2I(w[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MultiplyAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x)))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(float64(F(w[i])))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x[i])))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(float64(F(w[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MultiplyAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(I(w[i]))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(I(w[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplyIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MultiplyASV(w AS, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(B2I(x))))
		}
		return r
	case F:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(float64(F(x)))))
		}
		return r
	case I:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(B2I(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MultiplySV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Divide returns w%x.
func Divide(w, x V) V {
	switch w := w.(type) {
	case F:
		return DivideFV(w, x)
	case I:
		return DivideIV(w, x)
	case AB:
		return DivideABV(w, x)
	case AF:
		return DivideAFV(w, x)
	case AI:
		return DivideAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Divide(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Divide(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func DivideFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(divide(w, x))
	case I:
		return F(divide(w, F(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), B2F(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), F(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := DivideFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func DivideIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(divide(F(w), x))
	case I:
		return F(divide(F(w), F(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), B2F(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), F(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := DivideIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func DivideABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(w[i]), B2F(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(w[i]), B2F(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := DivideBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func DivideAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), B2F(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), B2F(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := DivideFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func DivideAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), B2F(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), B2F(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := DivideIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Minimum returns w&x.
func Minimum(w, x V) V {
	switch w := w.(type) {
	case F:
		return MinimumFV(w, x)
	case I:
		return MinimumIV(w, x)
	case S:
		return MinimumSV(w, x)
	case AB:
		return MinimumABV(w, x)
	case AF:
		return MinimumAFV(w, x)
	case AI:
		return MinimumAIV(w, x)
	case AS:
		return MinimumASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Minimum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Minimum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func MinimumFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Min(float64(w), float64(x))))
	case I:
		return F(F(math.Min(float64(w), float64(x))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(B2F(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MinimumFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MinimumIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Min(float64(w), float64(x))))
	case I:
		return I(minI(w, x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), B2I(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MinimumIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MinimumSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(minS(w, x))
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MinimumSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MinimumABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(w[i] && x)
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(B2I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] && x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(B2I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MinimumAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(x)))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MinimumAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MinimumASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MinimumSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Maximum returns w|x.
func Maximum(w, x V) V {
	switch w := w.(type) {
	case F:
		return MaximumFV(w, x)
	case I:
		return MaximumIV(w, x)
	case S:
		return MaximumSV(w, x)
	case AB:
		return MaximumABV(w, x)
	case AF:
		return MaximumAFV(w, x)
	case AI:
		return MaximumAIV(w, x)
	case AS:
		return MaximumASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Maximum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Maximum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func MaximumFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Max(float64(w), float64(x))))
	case I:
		return F(F(math.Max(float64(w), float64(x))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(B2F(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MaximumFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MaximumIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Max(float64(w), float64(x))))
	case I:
		return I(maxI(w, x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), B2I(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MaximumIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MaximumSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(maxS(w, x))
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := MaximumSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MaximumABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(w[i] || x)
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(B2I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] || x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(B2I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MaximumAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(x)))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MaximumAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func MaximumASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := MaximumSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

// Modulus returns w mod x.
func Modulus(w, x V) V {
	switch w := w.(type) {
	case F:
		return ModulusFV(w, x)
	case I:
		return ModulusIV(w, x)
	case AB:
		return ModulusABV(w, x)
	case AF:
		return ModulusAFV(w, x)
	case AI:
		return ModulusAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := Modulus(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := Modulus(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errwType(w)
	}
}

func ModulusFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return I(modF(w, x))
	case I:
		return I(modF(w, F(x)))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w), F(B2I(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w), F(x[i])))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w), F(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := ModulusFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func ModulusIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return I(modF(F(w), x))
	case I:
		return I(modI(w, x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w), B2I(x[i])))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(I(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := ModulusIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func ModulusABV(w AB, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), B2I(x)))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(B2I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(B2I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := ModulusBV(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func ModulusAFV(w AF, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(B2I(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(B2I(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := ModulusFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}

func ModulusAIV(w AI, x V) V {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modI(I(w[i]), B2I(x)))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := ModulusIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errType(x)
	}
}
