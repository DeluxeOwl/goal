// Code generated by genop.pl. DO NOT EDIT.

package main

import (
	"math"
	"strings"
)

// Equal returns w=x.
func Equal(w, x O) O {
	switch w := w.(type) {
	case B:
		return EqualBO(w, x)
	case F:
		return EqualFO(w, x)
	case I:
		return EqualIO(w, x)
	case S:
		return EqualSO(w, x)
	case AB:
		return EqualABO(w, x)
	case AF:
		return EqualAFO(w, x)
	case AI:
		return EqualAIO(w, x)
	case AS:
		return EqualASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("=")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Equal(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Equal(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w == x
	case F:
		return B2F(w) == x
	case I:
		return B2I(w) == x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) == B(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) == I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := EqualBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w == B2F(x)
	case F:
		return w == x
	case I:
		return w == F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := EqualFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w == B2I(x)
	case F:
		return F(w) == x
	case I:
		return w == x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := EqualIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w == x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) == S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := EqualSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) == B(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) == B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) == I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AO, len(x))
		for i := range r {
			v := EqualBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AO, len(x))
		for i := range r {
			v := EqualFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AO, len(x))
		for i := range r {
			v := EqualIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

func EqualASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("=")
		}
		r := make(AO, len(x))
		for i := range r {
			v := EqualSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("=")
	}
}

// NotEqual returns w≠x.
func NotEqual(w, x O) O {
	switch w := w.(type) {
	case B:
		return NotEqualBO(w, x)
	case F:
		return NotEqualFO(w, x)
	case I:
		return NotEqualIO(w, x)
	case S:
		return NotEqualSO(w, x)
	case AB:
		return NotEqualABO(w, x)
	case AF:
		return NotEqualAFO(w, x)
	case AI:
		return NotEqualAIO(w, x)
	case AS:
		return NotEqualASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("≠")
			}
			r := make(AO, len(w))
			for i := range r {
				v := NotEqual(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := NotEqual(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w != x
	case F:
		return B2F(w) != x
	case I:
		return B2I(w) != x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) != B(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) != F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) != I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := NotEqualBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w != B2F(x)
	case F:
		return w != x
	case I:
		return w != F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) != B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) != F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) != F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := NotEqualFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w != B2I(x)
	case F:
		return F(w) != x
	case I:
		return w != x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) != B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) != F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) != I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := NotEqualIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w != x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) != S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := NotEqualSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) != B(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) != F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) != I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) != B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) != F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) != I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AO, len(x))
		for i := range r {
			v := NotEqualBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) != B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) != F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) != F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) != B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) != F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) != F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AO, len(x))
		for i := range r {
			v := NotEqualFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) != B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) != F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) != I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) != B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) != F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) != I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AO, len(x))
		for i := range r {
			v := NotEqualIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

func NotEqualASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) != S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) != S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≠")
		}
		r := make(AO, len(x))
		for i := range r {
			v := NotEqualSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≠")
	}
}

// Lesser returns w<x.
func Lesser(w, x O) O {
	switch w := w.(type) {
	case B:
		return LesserBO(w, x)
	case F:
		return LesserFO(w, x)
	case I:
		return LesserIO(w, x)
	case S:
		return LesserSO(w, x)
	case AB:
		return LesserABO(w, x)
	case AF:
		return LesserAFO(w, x)
	case AI:
		return LesserAIO(w, x)
	case AS:
		return LesserASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("<")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Lesser(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Lesser(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return !w && x
	case F:
		return B2F(w) < x
	case I:
		return B2I(w) < x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(!w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) < I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w < B2F(x)
	case F:
		return w < x
	case I:
		return w < F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w < B2I(x)
	case F:
		return F(w) < x
	case I:
		return w < x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w < x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) < S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(!w[i]) && B(x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(!w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) < I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

func LesserASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("<")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("<")
	}
}

// LesserEq returns w≤x.
func LesserEq(w, x O) O {
	switch w := w.(type) {
	case B:
		return LesserEqBO(w, x)
	case F:
		return LesserEqFO(w, x)
	case I:
		return LesserEqIO(w, x)
	case S:
		return LesserEqSO(w, x)
	case AB:
		return LesserEqABO(w, x)
	case AF:
		return LesserEqAFO(w, x)
	case AI:
		return LesserEqAIO(w, x)
	case AS:
		return LesserEqASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("≤")
			}
			r := make(AO, len(w))
			for i := range r {
				v := LesserEq(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := LesserEq(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return x || !w
	case F:
		return B2F(w) <= x
	case I:
		return B2I(w) <= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(x[i]) || B(!w))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) <= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) <= I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserEqBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w <= B2F(x)
	case F:
		return w <= x
	case I:
		return w <= F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) <= B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) <= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) <= F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserEqFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w <= B2I(x)
	case F:
		return F(w) <= x
	case I:
		return w <= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) <= B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) <= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) <= I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserEqIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w <= x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) <= S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := LesserEqSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(x) || B(!w[i]))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) <= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) <= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(x[i]) || B(!w[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) <= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) <= I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserEqBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) <= B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) <= B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) <= F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserEqFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) <= B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) <= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) <= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) <= B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) <= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) <= I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserEqIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

func LesserEqASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) <= S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) <= S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≤")
		}
		r := make(AO, len(x))
		for i := range r {
			v := LesserEqSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≤")
	}
}

// Greater returns w>x.
func Greater(w, x O) O {
	switch w := w.(type) {
	case B:
		return GreaterBO(w, x)
	case F:
		return GreaterFO(w, x)
	case I:
		return GreaterIO(w, x)
	case S:
		return GreaterSO(w, x)
	case AB:
		return GreaterABO(w, x)
	case AF:
		return GreaterAFO(w, x)
	case AI:
		return GreaterAIO(w, x)
	case AS:
		return GreaterASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen(">")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Greater(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Greater(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w && !x
	case F:
		return B2F(w) > x
	case I:
		return B2I(w) > x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(!x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) > I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w > B2F(x)
	case F:
		return w > x
	case I:
		return w > F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w > B2I(x)
	case F:
		return F(w) > x
	case I:
		return w > x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w > x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) > S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(!x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(!x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) > I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

func GreaterASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen(">")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype(">")
	}
}

// GreaterEq returns w≥x.
func GreaterEq(w, x O) O {
	switch w := w.(type) {
	case B:
		return GreaterEqBO(w, x)
	case F:
		return GreaterEqFO(w, x)
	case I:
		return GreaterEqIO(w, x)
	case S:
		return GreaterEqSO(w, x)
	case AB:
		return GreaterEqABO(w, x)
	case AF:
		return GreaterEqAFO(w, x)
	case AI:
		return GreaterEqAIO(w, x)
	case AS:
		return GreaterEqASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("≥")
			}
			r := make(AO, len(w))
			for i := range r {
				v := GreaterEq(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := GreaterEq(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w || !x
	case F:
		return B2F(w) >= x
	case I:
		return B2I(w) >= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) || B(!x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w)) >= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w)) >= I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterEqBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w >= B2F(x)
	case F:
		return w >= x
	case I:
		return w >= F(x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) >= B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) >= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) >= F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterEqFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w >= B2I(x)
	case F:
		return F(w) >= x
	case I:
		return w >= x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) >= B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) >= F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) >= I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterEqIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w >= x
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) >= S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := GreaterEqSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) || B(!x))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) >= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) >= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) || B(!x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(B(w[i])) >= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(B(w[i])) >= I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterEqBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) >= B2F(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) >= B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) >= F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterEqFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) >= B2I(B(x)))
		}
		return r
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) >= F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) >= I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) >= B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) >= F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) >= I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterEqIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

func GreaterEqASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) >= S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) >= S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("≥")
		}
		r := make(AO, len(x))
		for i := range r {
			v := GreaterEqSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("≥")
	}
}

// Add returns w+x.
func Add(w, x O) O {
	switch w := w.(type) {
	case B:
		return AddBO(w, x)
	case F:
		return AddFO(w, x)
	case I:
		return AddIO(w, x)
	case S:
		return AddSO(w, x)
	case AB:
		return AddABO(w, x)
	case AF:
		return AddAFO(w, x)
	case AI:
		return AddAIO(w, x)
	case AS:
		return AddASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("+")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Add(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Add(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return B2I(w) + B2I(x)
	case F:
		return B2F(w) + x
	case I:
		return B2I(w) + x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) + B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) + F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) + I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AddBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w + B2F(x)
	case F:
		return w + x
	case I:
		return w + F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AddFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w + B2I(x)
	case F:
		return F(w) + x
	case I:
		return w + x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) + F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AddIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return w + x
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w) + S(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AddSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) + I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AddBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AddFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AddIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

func AddASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(S(w[i]) + S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w[i]) + S(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("+")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AddSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("+")
	}
}

// Subtract returns w-x.
func Subtract(w, x O) O {
	switch w := w.(type) {
	case B:
		return SubtractBO(w, x)
	case F:
		return SubtractFO(w, x)
	case I:
		return SubtractIO(w, x)
	case S:
		return SubtractSO(w, x)
	case AB:
		return SubtractABO(w, x)
	case AF:
		return SubtractAFO(w, x)
	case AI:
		return SubtractAIO(w, x)
	case AS:
		return SubtractASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("-")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Subtract(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Subtract(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return B2I(w) - B2I(x)
	case F:
		return B2F(w) - x
	case I:
		return B2I(w) - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) - I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SubtractBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w - B2F(x)
	case F:
		return w - x
	case I:
		return w - F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SubtractFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w - B2I(x)
	case F:
		return F(w) - x
	case I:
		return w - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SubtractIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return strings.TrimSuffix(w, x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(S(w), S(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SubtractSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) - I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SubtractBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SubtractFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SubtractIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

func SubtractASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.TrimSuffix(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(S(w[i]), S(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("-")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SubtractSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("-")
	}
}

// Span returns w¬x.
func Span(w, x O) O {
	switch w := w.(type) {
	case B:
		return SpanBO(w, x)
	case F:
		return SpanFO(w, x)
	case I:
		return SpanIO(w, x)
	case AB:
		return SpanABO(w, x)
	case AF:
		return SpanAFO(w, x)
	case AI:
		return SpanAIO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("¬")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Span(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Span(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return 1 + B2I(w) - B2I(x)
	case F:
		return 1 + B2F(w) - x
	case I:
		return 1 + B2I(w) - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w)) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + B2F(B(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w)) - I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SpanBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return 1 + w - B2F(x)
	case F:
		return 1 + w - x
	case I:
		return 1 + w - F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w) - B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w) - F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w) - F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SpanFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return 1 + w - B2I(x)
	case F:
		return 1 + F(w) - x
	case I:
		return 1 + w - x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w) - B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(I(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w) - I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := SpanIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + B2F(B(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + B2F(B(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + B2I(B(w[i])) - I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SpanBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(w[i]) - F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SpanFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

func SpanAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + I(w[i]) - B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 + F(I(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 + I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w[i]) - B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 + F(I(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 + I(w[i]) - I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("¬")
		}
		r := make(AO, len(x))
		for i := range r {
			v := SpanIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("¬")
	}
}

// Multiply returns w×x.
func Multiply(w, x O) O {
	switch w := w.(type) {
	case B:
		return MultiplyBO(w, x)
	case F:
		return MultiplyFO(w, x)
	case I:
		return MultiplyIO(w, x)
	case S:
		return MultiplySO(w, x)
	case AB:
		return MultiplyABO(w, x)
	case AF:
		return MultiplyAFO(w, x)
	case AI:
		return MultiplyAIO(w, x)
	case AS:
		return MultiplyASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("×")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Multiply(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Multiply(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w && x
	case F:
		return B2F(w) * x
	case I:
		return B2I(w) * x
	case S:
		return strings.Repeat(x, B2I(w))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) * I(x[i]))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), B2I(B(w))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MultiplyBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w * B2F(x)
	case F:
		return w * x
	case I:
		return w * F(x)
	case S:
		return strings.Repeat(x, I(math.Round(w)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(I(x[i])))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(math.Round(F(w)))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MultiplyFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w * B2I(x)
	case F:
		return F(w) * x
	case I:
		return w * x
	case S:
		return strings.Repeat(x, w)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * I(x[i]))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(w)))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MultiplyIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplySO(w S, x O) O {
	switch x := x.(type) {
	case B:
		return strings.Repeat(w, B2I(x))
	case F:
		return strings.Repeat(w, I(math.Round(x)))
	case I:
		return strings.Repeat(w, x)
	case AB:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w), I(math.Round(F(x[i])))))
		}
		return r
	case AI:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MultiplySO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(x), B2I(B(w[i]))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), B2I(B(w[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MultiplyBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x)))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(x), I(math.Round(F(w[i])))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x[i])))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(math.Round(F(w[i])))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MultiplyFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(x), I(w[i])))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(x[i]), I(w[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MultiplyIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

func MultiplyASO(w AS, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(math.Round(F(x)))))
		}
		return r
	case I:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(math.Round(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(S(w[i]), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("×")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MultiplySO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("×")
	}
}

// Divide returns w÷x.
func Divide(w, x O) O {
	switch w := w.(type) {
	case B:
		return DivideBO(w, x)
	case F:
		return DivideFO(w, x)
	case I:
		return DivideIO(w, x)
	case AB:
		return DivideABO(w, x)
	case AF:
		return DivideAFO(w, x)
	case AI:
		return DivideAIO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("÷")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Divide(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Divide(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return divide(B2F(w), B2F(x))
	case F:
		return divide(B2F(w), x)
	case I:
		return divide(B2F(w), F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w)), B2F(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w)), F(I(x[i]))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := DivideBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return divide(w, B2F(x))
	case F:
		return divide(w, x)
	case I:
		return divide(w, F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), B2F(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w), F(I(x[i]))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := DivideFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return divide(F(w), B2F(x))
	case F:
		return divide(F(w), x)
	case I:
		return divide(F(w), F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), B2F(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w)), F(I(x[i]))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := DivideIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), B2F(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), B2F(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(B2F(B(w[i])), F(I(x[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AO, len(x))
		for i := range r {
			v := DivideBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), B2F(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), B2F(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(w[i]), F(I(x[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AO, len(x))
		for i := range r {
			v := DivideFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

func DivideAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), B2F(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), B2F(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divide(F(I(w[i])), F(I(x[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("÷")
		}
		r := make(AO, len(x))
		for i := range r {
			v := DivideIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("÷")
	}
}

// Minimum returns w⌊x.
func Minimum(w, x O) O {
	switch w := w.(type) {
	case B:
		return MinimumBO(w, x)
	case F:
		return MinimumFO(w, x)
	case I:
		return MinimumIO(w, x)
	case S:
		return MinimumSO(w, x)
	case AB:
		return MinimumABO(w, x)
	case AF:
		return MinimumAFO(w, x)
	case AI:
		return MinimumAIO(w, x)
	case AS:
		return MinimumASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("⌊")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Minimum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Minimum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w && x
	case F:
		return F(math.Min(float64(B2F(w)), float64(x)))
	case I:
		return minI(B2I(w), x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(B(w))), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(B2I(B(w)), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MinimumBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return F(math.Min(float64(w), float64(B2F(x))))
	case F:
		return F(math.Min(float64(w), float64(x)))
	case I:
		return F(math.Min(float64(w), float64(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MinimumFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return minI(w, B2I(x))
	case F:
		return F(math.Min(float64(w), float64(x)))
	case I:
		return minI(w, x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MinimumIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return minS(w, x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w), S(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MinimumSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(B(w[i]))), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(B2I(B(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(B(w[i]))), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(B2I(B(w[i])), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MinimumBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(B(x))))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MinimumFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MinimumIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

func MinimumASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌊")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MinimumSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌊")
	}
}

// Maximum returns w⌈x.
func Maximum(w, x O) O {
	switch w := w.(type) {
	case B:
		return MaximumBO(w, x)
	case F:
		return MaximumFO(w, x)
	case I:
		return MaximumIO(w, x)
	case S:
		return MaximumSO(w, x)
	case AB:
		return MaximumABO(w, x)
	case AF:
		return MaximumAFO(w, x)
	case AI:
		return MaximumAIO(w, x)
	case AS:
		return MaximumASO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("⌈")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Maximum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Maximum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w || x
	case F:
		return F(math.Max(float64(B2F(w)), float64(x)))
	case I:
		return maxI(B2I(w), x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) || B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(B(w))), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(B2I(B(w)), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MaximumBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return F(math.Max(float64(w), float64(B2F(x))))
	case F:
		return F(math.Max(float64(w), float64(x)))
	case I:
		return F(math.Max(float64(w), float64(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MaximumFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return maxI(w, B2I(x))
	case F:
		return F(math.Max(float64(w), float64(x)))
	case I:
		return maxI(w, x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MaximumIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumSO(w S, x O) O {
	switch x := x.(type) {
	case S:
		return maxS(w, x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w), S(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := MaximumSO(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(B(w[i]))), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(B2I(B(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(B(w[i]))), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(B2I(B(w[i])), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MaximumBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(B(x))))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(B(x[i]))))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MaximumFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MaximumIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

func MaximumASO(w AS, x O) O {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("⌈")
		}
		r := make(AO, len(x))
		for i := range r {
			v := MaximumSO(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("⌈")
	}
}

// And returns w∧x.
func And(w, x O) O {
	switch w := w.(type) {
	case B:
		return AndBO(w, x)
	case F:
		return AndFO(w, x)
	case I:
		return AndIO(w, x)
	case AB:
		return AndABO(w, x)
	case AF:
		return AndAFO(w, x)
	case AI:
		return AndAIO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("∧")
			}
			r := make(AO, len(w))
			for i := range r {
				v := And(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := And(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w && x
	case F:
		return B2F(w) * x
	case I:
		return B2I(w) * x
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) && B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w)) * I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AndBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return w * B2F(x)
	case F:
		return w * x
	case I:
		return w * F(x)
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * B2F(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AndFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return w * B2I(x)
	case F:
		return F(w) * x
	case I:
		return w * x
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * B2I(B(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * I(x[i]))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := AndIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) && B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(B(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(B(w[i])) * I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AndBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AndFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

func AndAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x)))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(B(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * I(x[i]))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("∧")
		}
		r := make(AO, len(x))
		for i := range r {
			v := AndIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∧")
	}
}

// Or returns w∨x.
func Or(w, x O) O {
	switch w := w.(type) {
	case B:
		return OrBO(w, x)
	case F:
		return OrFO(w, x)
	case I:
		return OrIO(w, x)
	case AB:
		return OrABO(w, x)
	case AF:
		return OrAFO(w, x)
	case AI:
		return OrAIO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("∨")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Or(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Or(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return w || x
	case F:
		return 1 - ((1 - B2F(w)) * (1 - x))
	case I:
		return 1 - ((1 - B2I(w)) * (1 - x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w) || B(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - B2F(B(w))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - B2I(B(w))) * (1 - I(x[i]))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := OrBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return 1 - ((1 - w) * (1 - B2F(x)))
	case F:
		return 1 - ((1 - w) * (1 - x))
	case I:
		return 1 - ((1 - w) * F(1-x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w)) * (1 - B2F(B(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w)) * (1 - F(x[i]))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w)) * F(1-I(x[i]))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := OrFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return 1 - ((1 - w) * (1 - B2I(x)))
	case F:
		return 1 - ((1 - F(w)) * (1 - x))
	case I:
		return 1 - ((1 - w) * (1 - x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w)) * (1 - B2I(B(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(I(w))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w)) * (1 - I(x[i]))))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := OrIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - B2F(B(w[i]))) * (1 - F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 - ((1 - B2I(B(w[i]))) * (1 - I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B(w[i]) || B(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - B2F(B(w[i]))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - B2I(B(w[i]))) * (1 - I(x[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AO, len(x))
		for i := range r {
			v := OrBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - B2F(B(x)))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - F(x))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * F(1-I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - B2F(B(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * (1 - F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(w[i])) * F(1-I(x[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AO, len(x))
		for i := range r {
			v := OrFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

func OrAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - B2I(B(x)))))
		}
		return r
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(1 - ((1 - F(I(w[i]))) * (1 - F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - B2I(B(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(1 - ((1 - F(I(w[i]))) * (1 - F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(1 - ((1 - I(w[i])) * (1 - I(x[i]))))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("∨")
		}
		r := make(AO, len(x))
		for i := range r {
			v := OrIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("∨")
	}
}

// Modulus returns w|x.
func Modulus(w, x O) O {
	switch w := w.(type) {
	case B:
		return ModulusBO(w, x)
	case F:
		return ModulusFO(w, x)
	case I:
		return ModulusIO(w, x)
	case AB:
		return ModulusABO(w, x)
	case AF:
		return ModulusAFO(w, x)
	case AI:
		return ModulusAIO(w, x)
	case AO:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return badlen("|")
			}
			r := make(AO, len(w))
			for i := range r {
				v := Modulus(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AO, len(w))
		for i := range r {
			v := Modulus(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusBO(w B, x O) O {
	switch x := x.(type) {
	case B:
		return modulus(B2I(w), B2I(x))
	case F:
		return modulus(B2I(w), I(x))
	case I:
		return modulus(B2I(w), x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w)), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w)), I(F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w)), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := ModulusBO(B(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusFO(w F, x O) O {
	switch x := x.(type) {
	case B:
		return modulus(I(w), B2I(x))
	case F:
		return modulus(I(w), I(x))
	case I:
		return modulus(I(w), x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w)), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w)), I(F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w)), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := ModulusFO(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusIO(w I, x O) O {
	switch x := x.(type) {
	case B:
		return modulus(w, B2I(x))
	case F:
		return modulus(w, I(x))
	case I:
		return modulus(w, x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w), B2I(B(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w), I(F(x[i]))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w), I(x[i])))
		}
		return r
	case AO:
		r := make([]O, len(x))
		for i := range r {
			v := ModulusIO(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusABO(w AB, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), B2I(B(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(B2I(B(w[i])), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AO, len(x))
		for i := range r {
			v := ModulusBO(B(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusAFO(w AF, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), B2I(B(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(F(w[i])), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AO, len(x))
		for i := range r {
			v := ModulusFO(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}

func ModulusAIO(w AI, x O) O {
	switch x := x.(type) {
	case B:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(w[i]), B2I(B(x))))
		}
		return r
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(F(x))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w[i]), B2I(B(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(F(x[i]))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modulus(I(w[i]), I(x[i])))
		}
		return r
	case AO:
		if len(w) != len(x) {
			return badlen("|")
		}
		r := make(AO, len(x))
		for i := range r {
			v := ModulusIO(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return badtype("|")
	}
}
