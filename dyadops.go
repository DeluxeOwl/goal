// Code generated by genop.pl. DO NOT EDIT.

package goal

import (
	"math"
	"strings"
)

// equal returns x=y.
func equal(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return equalFV(x, y)
	case I:
		return equalIV(x, y)
	case S:
		return equalSV(x, y)
	case AB:
		return equalABV(x, y)
	case AF:
		return equalAFV(x, y)
	case AI:
		return equalAIV(x, y)
	case AS:
		return equalASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := equal(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := equal(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "x", x)
	}
}

func equalFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(B2I(x == y))
	case I:
		return newBV(B2I(x == F(y)))
	case AB:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) == B2F(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) == F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) == F(I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := equalFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

func equalIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(B2I(F(x) == y))
	case I:
		return newBV(B2I(x == y))
	case AB:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x) == B2I(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(I(x)) == F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x) == I(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := equalIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

func equalSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(B2I(x == y))
	case AS:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(S(x) == S(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := equalSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

func equalABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(B2F(x[i]) == F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(B2I(x[i]) == I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(x[i] == y[i])
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(B2F(x[i]) == F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(B2I(x[i]) == I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := equalIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

func equalAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(x[i]) == F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(x[i]) == F(I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) == B2F(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) == F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) == F(I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := equalFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

func equalAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(I(x[i])) == F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(I(x[i]) == I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x[i]) == B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(I(x[i])) == F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x[i]) == I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := equalIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

func equalASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(S(x[i]) == S(y))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(S(x[i]) == S(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x=y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := equalSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x=y", "y", y)
	}
}

// lesser returns x<y.
func lesser(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return lesserFV(x, y)
	case I:
		return lesserIV(x, y)
	case S:
		return lesserSV(x, y)
	case AB:
		return lesserABV(x, y)
	case AF:
		return lesserAFV(x, y)
	case AI:
		return lesserAIV(x, y)
	case AS:
		return lesserASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := lesser(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := lesser(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "x", x)
	}
}

func lesserFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(B2I(x < y))
	case I:
		return newBV(B2I(x < F(y)))
	case AB:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) < B2F(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) < F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) < F(I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

func lesserIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(B2I(F(x) < y))
	case I:
		return newBV(B2I(x < y))
	case AB:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x) < B2I(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(I(x)) < F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x) < I(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

func lesserSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(B2I(x < y))
	case AS:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(S(x) < S(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

func lesserABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(B2F(x[i]) < F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(B2I(x[i]) < I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(!x[i] && y[i])
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(B2F(x[i]) < F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(B2I(x[i]) < I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

func lesserAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(x[i]) < F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(x[i]) < F(I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) < B2F(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) < F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) < F(I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

func lesserAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(I(x[i])) < F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(I(x[i]) < I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x[i]) < B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(I(x[i])) < F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x[i]) < I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

func lesserASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(S(x[i]) < S(y))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(S(x[i]) < S(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x<y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := lesserSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x<y", "y", y)
	}
}

// greater returns x>y.
func greater(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return greaterFV(x, y)
	case I:
		return greaterIV(x, y)
	case S:
		return greaterSV(x, y)
	case AB:
		return greaterABV(x, y)
	case AF:
		return greaterAFV(x, y)
	case AI:
		return greaterAIV(x, y)
	case AS:
		return greaterASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := greater(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := greater(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "x", x)
	}
}

func greaterFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(B2I(x > y))
	case I:
		return newBV(B2I(x > F(y)))
	case AB:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) > B2F(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) > F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x) > F(I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

func greaterIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(B2I(F(x) > y))
	case I:
		return newBV(B2I(x > y))
	case AB:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x) > B2I(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(I(x)) > F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x) > I(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

func greaterSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(B2I(x > y))
	case AS:
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(S(x) > S(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

func greaterABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(B2F(x[i]) > F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(B2I(x[i]) > I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(x[i] && !y[i])
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(B2F(x[i]) > F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(B2I(x[i]) > I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

func greaterAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(x[i]) > F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(x[i]) > F(I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) > B2F(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) > F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(x[i]) > F(I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

func greaterAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(F(I(x[i])) > F(y))
		}
		return newBV(r)
	case I:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(I(x[i]) > I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x[i]) > B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(F(I(x[i])) > F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(I(x[i]) > I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

func greaterASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AB, x.Len())
		for i := range r {
			r[i] = bool(S(x[i]) > S(y))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(S(x[i]) > S(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x>y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := greaterSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x>y", "y", y)
	}
}

// add returns x+y.
func add(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return addFV(x, y)
	case I:
		return addIV(x, y)
	case S:
		return addSV(x, y)
	case AB:
		return addABV(x, y)
	case AF:
		return addAFV(x, y)
	case AI:
		return addAIV(x, y)
	case AS:
		return addASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := add(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := add(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "x", x)
	}
}

func addFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(x + y))
	case I:
		return newBV(F(x + F(y)))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) + B2F(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) + F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) + F(I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := addFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

func addIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(x) + y))
	case I:
		return newBV(I(x + y))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x) + B2I(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(I(x)) + F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x) + I(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := addIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

func addSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(S(x + y))
	case AS:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(S(x) + S(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := addSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

func addABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(B2F(x[i]) + F(y))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) + I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) + B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(B2F(x[i]) + F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) + I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := addIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

func addAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(x[i]) + F(y))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(x[i]) + F(I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) + B2F(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) + F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) + F(I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := addFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

func addAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(I(x[i])) + F(y))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(I(x[i]) + I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x[i]) + B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(I(x[i])) + F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x[i]) + I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := addIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

func addASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(S(x[i]) + S(y))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(S(x[i]) + S(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x+y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := addSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x+y", "y", y)
	}
}

// subtract returns x-y.
func subtract(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return subtractFV(x, y)
	case I:
		return subtractIV(x, y)
	case S:
		return subtractSV(x, y)
	case AB:
		return subtractABV(x, y)
	case AF:
		return subtractAFV(x, y)
	case AI:
		return subtractAIV(x, y)
	case AS:
		return subtractASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := subtract(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := subtract(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "x", x)
	}
}

func subtractFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(x - y))
	case I:
		return newBV(F(x - F(y)))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) - B2F(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) - F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) - F(I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

func subtractIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(x) - y))
	case I:
		return newBV(I(x - y))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x) - B2I(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(I(x)) - F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x) - I(y[i]))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

func subtractSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(S(strings.TrimSuffix(string(x), string(y))))
	case AS:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(x)), string(S(y[i]))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

func subtractABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(B2F(x[i]) - F(y))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) - I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) - B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(B2F(x[i]) - F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) - I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

func subtractAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(x[i]) - F(y))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(x[i]) - F(I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) - B2F(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) - F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) - F(I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

func subtractAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(I(x[i])) - F(y))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(I(x[i]) - I(y))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x[i]) - B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(I(x[i])) - F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x[i]) - I(y[i]))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

func subtractASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(x[i])), string(S(y))))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(x[i])), string(S(y[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x-y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := subtractSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x-y", "y", y)
	}
}

// multiply returns x*y.
func multiply(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return multiplyFV(x, y)
	case I:
		return multiplyIV(x, y)
	case S:
		return multiplySV(x, y)
	case AB:
		return multiplyABV(x, y)
	case AF:
		return multiplyAFV(x, y)
	case AI:
		return multiplyAIV(x, y)
	case AS:
		return multiplyASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := multiply(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := multiply(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "x", x)
	}
}

func multiplyFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(x * y))
	case I:
		return newBV(F(x * F(y)))
	case S:
		return newBV(S(strings.Repeat(string(y), int(float64(x)))))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) * B2F(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) * F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x) * F(I(y[i])))
		}
		return newBV(r)
	case AS:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y[i])), int(float64(F(x)))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplyFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

func multiplyIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(x) * y))
	case I:
		return newBV(I(x * y))
	case S:
		return newBV(S(strings.Repeat(string(y), int(x))))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x) * B2I(y[i]))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(I(x)) * F(y[i]))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x) * I(y[i]))
		}
		return newBV(r)
	case AS:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y[i])), int(I(x))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplyIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

func multiplySV(x S, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(S(strings.Repeat(string(x), int(float64(y)))))
	case I:
		return newBV(S(strings.Repeat(string(x), int(y))))
	case AB:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(B2I(y[i]))))
		}
		return newBV(r)
	case AF:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(I(y[i]))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplySV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

func multiplyABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(B2F(x[i]) * F(y))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) * I(y))
		}
		return newBV(r)
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y)), int(B2I(x[i]))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(x[i] && y[i])
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(B2F(x[i]) * F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(B2I(x[i]) * I(y[i]))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y[i])), int(B2I(x[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplyIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

func multiplyAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(x[i]) * F(y))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(x[i]) * F(I(y)))
		}
		return newBV(r)
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y)), int(float64(F(x[i])))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) * B2F(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) * F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(x[i]) * F(I(y[i])))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y[i])), int(float64(F(x[i])))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplyFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

func multiplyAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(I(x[i])) * F(y))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(I(x[i]) * I(y))
		}
		return newBV(r)
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y)), int(I(x[i]))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x[i]) * B2I(y[i]))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(I(x[i])) * F(y[i]))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(I(x[i]) * I(y[i]))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(y[i])), int(I(x[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplyIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

func multiplyASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(I(y))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(B2I(y[i]))))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(I(y[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x*y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := multiplySV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x*y", "y", y)
	}
}

// divide returns x%y.
func divide(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return divideFV(x, y)
	case I:
		return divideIV(x, y)
	case AB:
		return divideABV(x, y)
	case AF:
		return divideAFV(x, y)
	case AI:
		return divideAIV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := divide(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := divide(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x%%y", "x", x)
	}
}

func divideFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(divideF(x, y)))
	case I:
		return newBV(F(divideF(x, F(y))))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(x), B2F(y[i])))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(x), F(y[i])))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(x), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := divideFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x%%y", "y", y)
	}
}

func divideIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(divideF(F(x), y)))
	case I:
		return newBV(F(divideF(F(x), F(y))))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x)), B2F(y[i])))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x)), F(y[i])))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x)), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := divideIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x%%y", "y", y)
	}
}

func divideABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(divideF(B2F(x[i]), F(y)))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(divideF(B2F(x[i]), F(I(y))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(B2F(x[i]), B2F(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(B2F(x[i]), F(y[i])))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(B2F(x[i]), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := divideIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x%%y", "y", y)
	}
}

func divideAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(divideF(F(x[i]), F(y)))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(divideF(F(x[i]), F(I(y))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(x[i]), B2F(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(x[i]), F(y[i])))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(x[i]), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := divideFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x%%y", "y", y)
	}
}

func divideAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x[i])), F(y)))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x[i])), F(I(y))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x[i])), B2F(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x[i])), F(y[i])))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(divideF(F(I(x[i])), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x%%y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := divideIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x%%y", "y", y)
	}
}

// minimum returns x&y.
func minimum(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return minimumFV(x, y)
	case I:
		return minimumIV(x, y)
	case S:
		return minimumSV(x, y)
	case AB:
		return minimumABV(x, y)
	case AF:
		return minimumAFV(x, y)
	case AI:
		return minimumAIV(x, y)
	case AS:
		return minimumASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := minimum(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := minimum(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "x", x)
	}
}

func minimumFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(math.Min(float64(x), float64(y)))))
	case I:
		return newBV(F(F(math.Min(float64(x), float64(y)))))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x)), float64(B2F(y[i])))))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x)), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x)), float64(I(y[i])))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

func minimumIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(math.Min(float64(x), float64(y)))))
	case I:
		return newBV(I(minI(x, y)))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(minI(I(x), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(x)), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(minI(I(x), I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

func minimumSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(S(minS(x, y)))
	case AS:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(minS(S(x), S(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

func minimumABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(x[i])), float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(minI(B2I(x[i]), I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(x[i] && y[i])
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(x[i])), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(minI(B2I(x[i]), I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

func minimumAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x[i])), float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x[i])), float64(I(y)))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x[i])), float64(B2F(y[i])))))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x[i])), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(x[i])), float64(I(y[i])))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

func minimumAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(x[i])), float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(minI(I(x[i]), I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(minI(I(x[i]), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(x[i])), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(minI(I(x[i]), I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

func minimumASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(minS(S(x[i]), S(y)))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(minS(S(x[i]), S(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x&y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := minimumSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x&y", "y", y)
	}
}

// maximum returns x|y.
func maximum(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return maximumFV(x, y)
	case I:
		return maximumIV(x, y)
	case S:
		return maximumSV(x, y)
	case AB:
		return maximumABV(x, y)
	case AF:
		return maximumAFV(x, y)
	case AI:
		return maximumAIV(x, y)
	case AS:
		return maximumASV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := maximum(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := maximum(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "x", x)
	}
}

func maximumFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(math.Max(float64(x), float64(y)))))
	case I:
		return newBV(F(F(math.Max(float64(x), float64(y)))))
	case AB:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x)), float64(B2F(y[i])))))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x)), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x)), float64(I(y[i])))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

func maximumIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(F(F(math.Max(float64(x), float64(y)))))
	case I:
		return newBV(I(maxI(x, y)))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(maxI(I(x), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(x)), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(maxI(I(x), I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

func maximumSV(x S, y V) V {
	switch y := y.BV.(type) {
	case S:
		return newBV(S(maxS(x, y)))
	case AS:
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(maxS(S(x), S(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumSV(S(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

func maximumABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(x[i])), float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(maxI(B2I(x[i]), I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AB, y.Len())
		for i := range r {
			r[i] = bool(x[i] || y[i])
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(x[i])), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(maxI(B2I(x[i]), I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

func maximumAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x[i])), float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x[i])), float64(I(y)))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x[i])), float64(B2F(y[i])))))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x[i])), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(x[i])), float64(I(y[i])))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

func maximumAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AF, x.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(x[i])), float64(F(y)))))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(maxI(I(x[i]), I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(maxI(I(x[i]), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AF, y.Len())
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(x[i])), float64(F(y[i])))))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(maxI(I(x[i]), I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

func maximumASV(x AS, y V) V {
	switch y := y.BV.(type) {
	case S:
		r := make(AS, x.Len())
		for i := range r {
			r[i] = string(maxS(S(x[i]), S(y)))
		}
		return newBV(r)
	case AS:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AS, y.Len())
		for i := range r {
			r[i] = string(maxS(S(x[i]), S(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x|y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := maximumSV(S(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x|y", "y", y)
	}
}

// modulus returns x mod y.
func modulus(x, y V) V {
	switch x := x.BV.(type) {
	case F:
		return modulusFV(x, y)
	case I:
		return modulusIV(x, y)
	case AB:
		return modulusABV(x, y)
	case AF:
		return modulusAFV(x, y)
	case AI:
		return modulusAIV(x, y)
	case AV:
		switch y := y.BV.(type) {
		case array:
			if y.Len() != x.Len() {
				return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
			}
			r := make(AV, x.Len())
			for i := range r {
				ri := modulus(x[i], y.at(i))
				if isErr(ri) {
					return ri
				}
				r[i] = ri
			}
			return newBV(r)
		}
		r := make(AV, x.Len())
		for i := range r {
			ri := modulus(x[i], y)
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x mod y", "x", x)
	}
}

func modulusFV(x F, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(I(modF(x, y)))
	case I:
		return newBV(I(modF(x, F(y))))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(x), F(B2I(y[i]))))
		}
		return newBV(r)
	case AF:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(x), F(y[i])))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(x), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := modulusFV(F(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x mod y", "y", y)
	}
}

func modulusIV(x I, y V) V {
	switch y := y.BV.(type) {
	case F:
		return newBV(I(modF(F(x), y)))
	case I:
		return newBV(I(modI(x, y)))
	case AB:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modI(I(x), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(I(x)), F(y[i])))
		}
		return newBV(r)
	case AI:
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modI(I(x), I(y[i])))
		}
		return newBV(r)
	case AV:
		r := make(AV, y.Len())
		for i := range r {
			ri := modulusIV(I(x), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x mod y", "y", y)
	}
}

func modulusABV(x AB, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(modF(F(B2I(x[i])), F(y)))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(modI(B2I(x[i]), I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modI(B2I(x[i]), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(B2I(x[i])), F(y[i])))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modI(B2I(x[i]), I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := modulusIV(B2I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x mod y", "y", y)
	}
}

func modulusAFV(x AF, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(modF(F(x[i]), F(y)))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(modF(F(x[i]), F(I(y))))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(x[i]), F(B2I(y[i]))))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(x[i]), F(y[i])))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(x[i]), F(I(y[i]))))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := modulusFV(F(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x mod y", "y", y)
	}
}

func modulusAIV(x AI, y V) V {
	switch y := y.BV.(type) {
	case F:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(modF(F(I(x[i])), F(y)))
		}
		return newBV(r)
	case I:
		r := make(AI, x.Len())
		for i := range r {
			r[i] = int(modI(I(x[i]), I(y)))
		}
		return newBV(r)
	case AB:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modI(I(x[i]), B2I(y[i])))
		}
		return newBV(r)
	case AF:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modF(F(I(x[i])), F(y[i])))
		}
		return newBV(r)
	case AI:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AI, y.Len())
		for i := range r {
			r[i] = int(modI(I(x[i]), I(y[i])))
		}
		return newBV(r)
	case AV:
		if x.Len() != y.Len() {
			return errf("x mod y : length mismatch: %d vs %d", x.Len(), y.Len())
		}
		r := make(AV, y.Len())
		for i := range r {
			ri := modulusIV(I(x[i]), y[i])
			if isErr(ri) {
				return ri
			}
			r[i] = ri
		}
		return newBV(r)
	default:
		return errType("x mod y", "y", y)
	}
}
