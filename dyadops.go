// Code generated by genop.pl. DO NOT EDIT.

package goal

import (
	"math"
	"strings"
)

// equal returns w=x.
func equal(w, x V) V {
	switch w := w.(type) {
	case F:
		return equalFV(w, x)
	case I:
		return equalIV(w, x)
	case S:
		return equalSV(w, x)
	case AB:
		return equalABV(w, x)
	case AF:
		return equalAFV(w, x)
	case AI:
		return equalAIV(w, x)
	case AS:
		return equalASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x=y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := equal(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := equal(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for x", w.Type())
	}
}

func equalFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(w == x)
	case I:
		return B2I(w == F(x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == B2F(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) == F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := equalFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

func equalIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(F(w) == x)
	case I:
		return B2I(w == x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == B2I(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) == F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) == I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := equalIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

func equalSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return B2I(w == x)
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) == S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := equalSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

func equalABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(w[i]) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(w[i]) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] == x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(w[i]) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(w[i]) == I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := equalIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

func equalAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) == F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := equalFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

func equalAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) == F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) == I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := equalIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

func equalASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) == S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x=y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := equalSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x=y : bad type `%s for y", x.Type())
	}
}

// lesser returns w<x.
func lesser(w, x V) V {
	switch w := w.(type) {
	case F:
		return lesserFV(w, x)
	case I:
		return lesserIV(w, x)
	case S:
		return lesserSV(w, x)
	case AB:
		return lesserABV(w, x)
	case AF:
		return lesserAFV(w, x)
	case AI:
		return lesserAIV(w, x)
	case AS:
		return lesserASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x<y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := lesser(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := lesser(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for x", w.Type())
	}
}

func lesserFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(w < x)
	case I:
		return B2I(w < F(x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < B2F(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) < F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := lesserFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

func lesserIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(F(w) < x)
	case I:
		return B2I(w < x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < B2I(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) < F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) < I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := lesserIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

func lesserSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return B2I(w < x)
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) < S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := lesserSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

func lesserABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(w[i]) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(w[i]) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(!w[i] && x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(w[i]) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(w[i]) < I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := lesserIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

func lesserAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) < F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := lesserFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

func lesserAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) < F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) < I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := lesserIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

func lesserASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) < S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x<y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := lesserSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x<y : bad type `%s for y", x.Type())
	}
}

// greater returns w>x.
func greater(w, x V) V {
	switch w := w.(type) {
	case F:
		return greaterFV(w, x)
	case I:
		return greaterIV(w, x)
	case S:
		return greaterSV(w, x)
	case AB:
		return greaterABV(w, x)
	case AF:
		return greaterAFV(w, x)
	case AI:
		return greaterAIV(w, x)
	case AS:
		return greaterASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x>y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := greater(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := greater(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for x", w.Type())
	}
}

func greaterFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(w > x)
	case I:
		return B2I(w > F(x))
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > B2F(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w) > F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := greaterFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

func greaterIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return B2I(F(w) > x)
	case I:
		return B2I(w > x)
	case AB:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > B2I(x[i]))
		}
		return r
	case AF:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w)) > F(x[i]))
		}
		return r
	case AI:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w) > I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := greaterIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

func greaterSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return B2I(w > x)
	case AS:
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w) > S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := greaterSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

func greaterABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2F(w[i]) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(B2I(w[i]) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] && !x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2F(w[i]) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(B2I(w[i]) > I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := greaterIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

func greaterAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(w[i]) > F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := greaterFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

func greaterAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x))
		}
		return r
	case I:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(F(I(w[i])) > F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(I(w[i]) > I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := greaterIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

func greaterASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AB, len(w))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(S(w[i]) > S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x>y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := greaterSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x>y : bad type `%s for y", x.Type())
	}
}

// add returns w+x.
func add(w, x V) V {
	switch w := w.(type) {
	case F:
		return addFV(w, x)
	case I:
		return addIV(w, x)
	case S:
		return addSV(w, x)
	case AB:
		return addABV(w, x)
	case AF:
		return addAFV(w, x)
	case AI:
		return addAIV(w, x)
	case AS:
		return addASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x+y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := add(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := add(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for x", w.Type())
	}
}

func addFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(w + x)
	case I:
		return F(w + F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + B2F(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) + F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := addFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

func addIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(w) + x)
	case I:
		return I(w + x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + B2I(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) + F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) + I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := addIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

func addSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(w + x)
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w) + S(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := addSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

func addABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(w[i]) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) + B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(w[i]) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) + I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := addIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

func addAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) + F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := addFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

func addAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) + I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) + F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) + I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := addIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

func addASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(S(w[i]) + S(x))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(S(w[i]) + S(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x+y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := addSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x+y : bad type `%s for y", x.Type())
	}
}

// subtract returns w-x.
func subtract(w, x V) V {
	switch w := w.(type) {
	case F:
		return subtractFV(w, x)
	case I:
		return subtractIV(w, x)
	case S:
		return subtractSV(w, x)
	case AB:
		return subtractABV(w, x)
	case AF:
		return subtractAFV(w, x)
	case AI:
		return subtractAIV(w, x)
	case AS:
		return subtractASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x-y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := subtract(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := subtract(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for x", w.Type())
	}
}

func subtractFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(w - x)
	case I:
		return F(w - F(x))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - B2F(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) - F(I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := subtractFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

func subtractIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(w) - x)
	case I:
		return I(w - x)
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - B2I(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) - F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) - I(x[i]))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := subtractIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

func subtractSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(strings.TrimSuffix(string(w), string(x)))
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(w)), string(S(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := subtractSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

func subtractABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) - B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := subtractIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

func subtractAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) - F(I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := subtractFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

func subtractAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) - I(x))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) - F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) - I(x[i]))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := subtractIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

func subtractASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(w[i])), string(S(x))))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.TrimSuffix(string(S(w[i])), string(S(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x-y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := subtractSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x-y : bad type `%s for y", x.Type())
	}
}

// multiply returns w*x.
func multiply(w, x V) V {
	switch w := w.(type) {
	case F:
		return multiplyFV(w, x)
	case I:
		return multiplyIV(w, x)
	case S:
		return multiplySV(w, x)
	case AB:
		return multiplyABV(w, x)
	case AF:
		return multiplyAFV(w, x)
	case AI:
		return multiplyAIV(w, x)
	case AS:
		return multiplyASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x*y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := multiply(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := multiply(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for x", w.Type())
	}
}

func multiplyFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(w * x)
	case I:
		return F(w * F(x))
	case S:
		return S(strings.Repeat(string(x), int(float64(w))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * B2F(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(x[i]))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w) * F(I(x[i])))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(float64(F(w)))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := multiplyFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

func multiplyIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(w) * x)
	case I:
		return I(w * x)
	case S:
		return S(strings.Repeat(string(x), int(w)))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * B2I(x[i]))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w)) * F(x[i]))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w) * I(x[i]))
		}
		return r
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(I(w))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := multiplyIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

func multiplySV(w S, x V) V {
	switch x := x.(type) {
	case F:
		return S(strings.Repeat(string(w), int(float64(x))))
	case I:
		return S(strings.Repeat(string(w), int(x)))
	case AB:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w)), int(B2I(x[i]))))
		}
		return r
	case AF:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w)), int(float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w)), int(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := multiplySV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

func multiplyABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(B2F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(B2I(w[i]) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(B2I(w[i]))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] && x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(B2F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(B2I(w[i]) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(B2I(w[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := multiplyIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

func multiplyAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x)))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(float64(F(w[i])))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * B2F(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(w[i]) * F(I(x[i])))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(float64(F(w[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := multiplyFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

func multiplyAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(I(w[i]) * I(x))
		}
		return r
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(I(w[i]))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * B2I(x[i]))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(I(w[i])) * F(x[i]))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(I(w[i]) * I(x[i]))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x[i])), int(I(w[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := multiplyIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

func multiplyASV(w AS, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(float64(F(x)))))
		}
		return r
	case I:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(B2I(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(strings.Repeat(string(S(w[i])), int(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x*y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := multiplySV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x*y : bad type `%s for y", x.Type())
	}
}

// divide returns w%x.
func divide(w, x V) V {
	switch w := w.(type) {
	case F:
		return divideFV(w, x)
	case I:
		return divideIV(w, x)
	case AB:
		return divideABV(w, x)
	case AF:
		return divideAFV(w, x)
	case AI:
		return divideAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x%%y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := divide(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := divide(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x%%y : bad type `%s for x", w.Type())
	}
}

func divideFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(divideF(w, x))
	case I:
		return F(divideF(w, F(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(w), B2F(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(w), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(w), F(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := divideFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x%%y : bad type `%s for y", x.Type())
	}
}

func divideIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(divideF(F(w), x))
	case I:
		return F(divideF(F(w), F(x)))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(I(w)), B2F(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(I(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(I(w)), F(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := divideIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x%%y : bad type `%s for y", x.Type())
	}
}

func divideABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divideF(B2F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divideF(B2F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(B2F(w[i]), B2F(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(B2F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(B2F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := divideIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x%%y : bad type `%s for y", x.Type())
	}
}

func divideAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divideF(F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divideF(F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(w[i]), B2F(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := divideFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x%%y : bad type `%s for y", x.Type())
	}
}

func divideAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divideF(F(I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(divideF(F(I(w[i])), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(I(w[i])), B2F(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(divideF(F(I(w[i])), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x%%y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := divideIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x%%y : bad type `%s for y", x.Type())
	}
}

// minimum returns w&x.
func minimum(w, x V) V {
	switch w := w.(type) {
	case F:
		return minimumFV(w, x)
	case I:
		return minimumIV(w, x)
	case S:
		return minimumSV(w, x)
	case AB:
		return minimumABV(w, x)
	case AF:
		return minimumAFV(w, x)
	case AI:
		return minimumAIV(w, x)
	case AS:
		return minimumASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x&y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := minimum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := minimum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for x", w.Type())
	}
}

func minimumFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Min(float64(w), float64(x))))
	case I:
		return F(F(math.Min(float64(w), float64(x))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(B2F(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := minimumFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

func minimumIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Min(float64(w), float64(x))))
	case I:
		return I(minI(w, x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), B2I(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := minimumIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

func minimumSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(minS(w, x))
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := minimumSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

func minimumABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(B2I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] && x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(B2F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(B2I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := minimumIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

func minimumAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(B2F(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := minimumFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

func minimumAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Min(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(minI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := minimumIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

func minimumASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(minS(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x&y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := minimumSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x&y : bad type `%s for y", x.Type())
	}
}

// maximum returns w|x.
func maximum(w, x V) V {
	switch w := w.(type) {
	case F:
		return maximumFV(w, x)
	case I:
		return maximumIV(w, x)
	case S:
		return maximumSV(w, x)
	case AB:
		return maximumABV(w, x)
	case AF:
		return maximumAFV(w, x)
	case AI:
		return maximumAIV(w, x)
	case AS:
		return maximumASV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x|y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := maximum(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := maximum(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for x", w.Type())
	}
}

func maximumFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Max(float64(w), float64(x))))
	case I:
		return F(F(math.Max(float64(w), float64(x))))
	case AB:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(B2F(x[i])))))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w)), float64(I(x[i])))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := maximumFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

func maximumIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return F(F(math.Max(float64(w), float64(x))))
	case I:
		return I(maxI(w, x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), B2I(x[i])))
		}
		return r
	case AF:
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w)), float64(F(x[i])))))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := maximumIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

func maximumSV(w S, x V) V {
	switch x := x.(type) {
	case S:
		return S(maxS(w, x))
	case AS:
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w), S(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := maximumSV(S(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

func maximumABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(B2I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AB, len(x))
		for i := range r {
			r[i] = bool(w[i] || x[i])
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(B2F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(B2I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := maximumIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

func maximumAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x)))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(B2F(x[i])))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(F(w[i])), float64(I(x[i])))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := maximumFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

func maximumAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AF, len(w))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x)))))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AF, len(x))
		for i := range r {
			r[i] = float64(F(math.Max(float64(I(w[i])), float64(F(x[i])))))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(maxI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := maximumIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

func maximumASV(w AS, x V) V {
	switch x := x.(type) {
	case S:
		r := make(AS, len(w))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x)))
		}
		return r
	case AS:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AS, len(x))
		for i := range r {
			r[i] = string(maxS(S(w[i]), S(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x|y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := maximumSV(S(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x|y : bad type `%s for y", x.Type())
	}
}

// modulus returns w mod x.
func modulus(w, x V) V {
	switch w := w.(type) {
	case F:
		return modulusFV(w, x)
	case I:
		return modulusIV(w, x)
	case AB:
		return modulusABV(w, x)
	case AF:
		return modulusAFV(w, x)
	case AI:
		return modulusAIV(w, x)
	case AV:
		switch x := x.(type) {
		case Array:
			if x.Len() != len(w) {
				return errf("x mod y : length mismatch: %d vs %d", len(w), x.Len())
			}
			r := make(AV, len(w))
			for i := range r {
				v := modulus(w[i], x.At(i))
				e, ok := v.(E)
				if ok {
					return e
				}
				r[i] = v
			}
			return r
		}
		r := make(AV, len(w))
		for i := range r {
			v := modulus(w[i], x)
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x mod y : bad type `%s for x", w.Type())
	}
}

func modulusFV(w F, x V) V {
	switch x := x.(type) {
	case F:
		return I(modF(w, x))
	case I:
		return I(modF(w, F(x)))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w), F(B2I(x[i]))))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w), F(x[i])))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w), F(I(x[i]))))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := modulusFV(F(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x mod y : bad type `%s for y", x.Type())
	}
}

func modulusIV(w I, x V) V {
	switch x := x.(type) {
	case F:
		return I(modF(F(w), x))
	case I:
		return I(modI(w, x))
	case AB:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w), B2I(x[i])))
		}
		return r
	case AF:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(I(w)), F(x[i])))
		}
		return r
	case AI:
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w), I(x[i])))
		}
		return r
	case AV:
		r := make(AV, len(x))
		for i := range r {
			v := modulusIV(I(w), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x mod y : bad type `%s for y", x.Type())
	}
}

func modulusABV(w AB, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(B2I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(B2I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(B2I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := modulusIV(B2I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x mod y : bad type `%s for y", x.Type())
	}
}

func modulusAFV(w AF, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(x)))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(I(x))))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(B2I(x[i]))))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(w[i]), F(I(x[i]))))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := modulusFV(F(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x mod y : bad type `%s for y", x.Type())
	}
}

func modulusAIV(w AI, x V) V {
	switch x := x.(type) {
	case F:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modF(F(I(w[i])), F(x)))
		}
		return r
	case I:
		r := make(AI, len(w))
		for i := range r {
			r[i] = int(modI(I(w[i]), I(x)))
		}
		return r
	case AB:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w[i]), B2I(x[i])))
		}
		return r
	case AF:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modF(F(I(w[i])), F(x[i])))
		}
		return r
	case AI:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AI, len(x))
		for i := range r {
			r[i] = int(modI(I(w[i]), I(x[i])))
		}
		return r
	case AV:
		if len(w) != len(x) {
			return errf("x mod y : length mismatch: %d vs %d", len(w), len(x))
		}
		r := make(AV, len(x))
		for i := range r {
			v := modulusIV(I(w[i]), x[i])
			e, ok := v.(E)
			if ok {
				return e
			}
			r[i] = v
		}
		return r
	case E:
		return w
	default:
		return errf("x mod y : bad type `%s for y", x.Type())
	}
}
